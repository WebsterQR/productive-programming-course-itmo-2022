# Модульный дизайн (лекция 9)

Основыне способы борьбы со сложностью кода
- упрощение локальных частей кода
- модульный дизайн - оптимизация основных задач модуля, его интерфейсов, и связей между модулями

### Модуль - это что-либо, у чего есть интерфейс и реализация (микросервис, класс, функция и т.д.)

Модули могут зависить друг от друга (на картинке обозначено стрелочками):

![image](https://user-images.githubusercontent.com/57497898/213812478-fe41034e-38c5-4b64-9da4-1f7e398c3851.png)

Вообще зависимости могут быть неявными. Например часто это происходит на фронтенде в event driven архитектурах *(во Vue.js это $emit и $on)*

При настройке зависимостей между модулями, можем столкнутьс с двумя проблемами: Change Amplification и Cognitive Load (см лекцию 8)

## Уменьшение сложности от Change Amplification
Change Amplification Scope при изменении модуля - это те модули которое связаны с текущим (дфс по графу модулей по стрелочкам). Наша задача как можно сильнее пытаться уменьшить его, чтобы изменения минимально влияли на другие модули.

Не делайте слишком много слоев модулей. Особенно если на каком-то модуле у вас просто идет вызов другого модуля - так делать плохо.
Наоборот, если у слоев разные абстракции (сигнатуры у методов например), то все ок.

Далее два примера, где модули - функции

Плохо
```java
int module1(int arg1, int arg2) {
    return module2(arg1, arg2);
}
```

Хорошо
```java
int module1(int arg1, int arg2) {
    int res1 = module1(arg1);
    int res2 = module2(arg2);
    return merge(res1, res2)
}
```

<br>

> *Пояснение что такое слои модулей:*
> 
> *Вы можете посмотреть на stacktrace любой программы, каждый уровень отображает отдельный модуль (функцию). Эти функции вызывают друг друга, образуя слои вызовов. Например на следующей картинке слои:* <br> *main -> nextFloat -> next -> throwFor*
>
> *Можно посмотреть на слои и более глобально: классы же тоже являются модулями. Тогда слои будут:* <br> *com.example.myJavaProject.hello -> java.util.Scanner*
> 
> ![image](https://user-images.githubusercontent.com/57497898/213817812-0470fdd0-3bea-4905-ada3-d6e3c6ab9ce3.png)

<br>

Методы борьбы с Change Amplification
- четкое разделение обязанностей сервисов (никакой модуль не делает то, что не входит в его прямые обязанности)
- нет ненужных слоев модулей

## Уменьшение сложности с помощью зависимостей модулей
Методы с помощью которых можно уменьшить сложность через зависимости:
- уменьшить количество зависимостей модуля
- упростить интерфейсы модулей которые испозует модуль
- убедиться что вы не зависите от плохих модулей - тех которые backward compatible и апи которых работает пмо спецификации

Про 3й пункт: *тут должна быть история Артема про то, как в Google распустили команду, когда они удалили АПИ-шку из сервиса*

Табличка про то как уменьшение сложности через зависимости устраняет Cognitive Load и Change Amplification

![image](https://user-images.githubusercontent.com/57497898/213822363-150937e5-4508-41ca-bdd0-894ba6df6143.png)

> 3й пункт про плохие модули тут поделен на два 
>
> Про пустую клеточку на лекции была дискуссия: к единому выводу так и не пришли. Я считаю, что там должен быть минус, так как прямой зависимости нет. Хотя, если считать, что все известные модули стабильны (как предложил Артем), из этого следует что там плюс... ну не знаю, up to you. 
