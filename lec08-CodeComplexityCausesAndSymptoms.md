# Причины и признаки сложного кода (лекция 8)

Правило: исбавляйтесь от нопределенности в коде как можно раньше

```c++
for (pair<string, int> p: getInfo()) {
    // надо сразу пояснять кодом, что такое first, 
    // а что такое second в p
    string attribute = p.first;
    int value = p.second;
    ...
} 
```

```java
// старайтесь сразу избавляться от optional и nullable переменных
Optional<Long> studentIdOpt = getStudentId();

if (studentIdOpt.isPresent()) {
    long studentId = studentIdOpt.get();
    ...
} else {
    ...
}
```

```java
// если пользуетесь массовой апи для нахождения одного конкретного элемента
// то сразу вытаскивайте его из списка
List<String> teamNameInList = getTeamNamesByIds(singletonList(1L));

if (teamNameInList.size() == 1) {
    String teamName = teamNameInList.get(0);
    ...
} else {
    throw new RuntimeException();
}
```

Чем более знание локально, тем легче система. Например, если вы используете неочевидную аббревиатуру в одном файле, система выходит проще, чем если бы вы её использовали во всем модуле/проекте

Локальность знаний облегчает понимание и снижает риски при внесении правок в код

----

## Тактическое программирование vs Стратегическое программирование

Тактическое программирование
- вопрос сложности не рассматривается
- фокус на скорости написания новых фич
- часто делаются быстрые (костыльные) фиксы багов

В большинстве случаев из тактического программирования нельзя перейти в стратегического (нет пути назад)

В команде часто есть люди которые программируют тактически, так как так быстрее получается выполнить задачи, но в перспективе это не очень хорошо. Таких людей в шутку называют "Product manager heroes".

Скорость разработки в зависимости от стиля программирования (тактического и стратегического):
![image](https://user-images.githubusercontent.com/57497898/213716488-a26aafb9-d8d9-4e2d-a757-f402e2483555.png)

Основные столпы на которых держится стратегическое программирование (*Жирный шрифт на первом столбце случайно*):
![image](https://user-images.githubusercontent.com/57497898/213717111-d50c6885-c6af-403d-a22e-3c393e64c9c4.png)

----

Сложность - что-либо имеющее отношение к структуре ПО, что усложняет понимание и изменение системы

<br>

Численное значение сложности можно вычислить например так:
### $C = \sum_p c_p t_p$

где 
- p - часть проекта
- t_p - время которое на него тратится
- с_p - cложность части проекта

<br>

Сложность оценивается не автором кода, а тем кто его будет потом поддерживать, так как автор не объективен

Спрятать сложность так глубоко в реализацию, что её никто никогда не увидит, равносильно убиранию проблемы

## Симптомы сложности
- Change Amplification (кажется что нужно исправить пару строк, а в итоге правки в 10 файлах)
- Cognitive Load (слишком сложная умственная нагрузка при чтении кода)
- Unknown Unknowns (непонятно с чего начать добавление фичи, и как связаны части системы)

### Change Aplification
Пример Change Amplification: есть однаковая захардкоженная константа в нескольких файлах. Её нажно найти и исправить везде

Основная проблема: время на изменение

### Cognitive Load
То, сколько разработчик должен понимать и помнить чтобы сделать задачу.

Пример Cognitive Load: 
- аллокация памяти в C *(Не делайте код более сложным, не используйте С и С++... ой что?)*
- API в котором слишком много методов
- метод с большим количеством параметров 
- глобальные переменные
- ...

Проблемы:
- порог вхождения в код выше (некоторые разработчики вообще не смогут понять что происходит)
- можно что-то забыть или не учесть, что порождает баги

### Unknown unknowns
Пример: есть константа BACKGROUND_COLOR и в одном месте написано следующее:
```java 
this.backgroundColor = "dark " + BACKGROUND_COLOR
```
И получается есть неявная зависимость, которая при изменении BACKGROUND_COLOR выстрелит в ногу

### Итог про симптомы сложности

Код сложный, если его сложно менять

----

## Мудрая история

Спустя какое-то время разработки ваш старый код может выглядеть как забор на следующей картинке:
![image](https://user-images.githubusercontent.com/57497898/213729991-27db2671-1033-4dac-9ab9-a0f457f4d55c.png)

Он ни к селу не к городу. И вы полные решимости приходите к тимлиду с вопросом, можно ли его убрать. А он в этвет говорит что можно, но только сначала надо понять зачем он там стоит. Ведь есть вероятность что при убаирания такого "забора" вы сломаете что-то еще

## Причины сложности
- зависимости
- obscurity (скрытность, неявность)

### Зависимость
Пример (бэкграунд a, b и c должен быть одинаковым):
```java
a.bg = "red";
...
b.bg = "red";
...
c.bg = "red";
```

То есть мы не можем изменить один кусок кода, без изменения второго (не можем изменить a.bg, не поненяв b.bg и c.bg)

Признаки зависимости
- мы не можем изменить конкретную часть кода, без изменения других частей
- это неизбежное зло, полностью избавиться от этого нельзя
- степень сложности исправления может быть разная (поменять в одном месте, поменять в ста местах)

Еще примеры:
- decoder и encoder должны быть в одинаковой кодировке
- сигнатура метода

### Obscurity
Obscurity - это когда часть информации скрыта или зашифрована

```
b = "red"
```

Непонятно что за b? Это background? Есть ли другие страницы с таким цветом?

### Причины и симптомы зависимостей
![image](https://user-images.githubusercontent.com/57497898/213735672-9916fba5-2098-4a83-850d-9c35c6fc732a.png)

Зависимости это одновременно источник сложности и наш главный инструмент, от них сложно избавиться. Намного легче избавиться от Obscurities, что хорошо, так как Unknown Unknows и Congnitive Load пораждают самые большие проблемы.

----

Что можно оптимизировать: 
- сложность 
- производительность 
- scalability (способность расширяться)
- скорость доставки новых фич
